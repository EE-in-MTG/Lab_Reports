<!-- INTRODUCTION SECTION -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<html>
<head> <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="stylesheet" href="https://latex.vercel.app/style.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css"/><script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]}};</script>

<title>Fractal Geometry Lab Report</title>

</head>
	
<body id="top">




  <header>
    <h1>Fractal Geometry Lab Report</h1>
    <p class="author">
      Joseph D Wilson <br />
      02/10/2025
    </p>
  </header>
  


  <main>
    <article class="indent-pars">
      
      <!-- INTRODUCTION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="introduction">
        <h2>Introduction</h2>
        <p>
          Lab 2 is for generating random walks called Brownian motion and implement Koch and dragon curves using Python Turtle graphics in a Google notebook environment.

        </p>
      </section>


     
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<section id="code">
	<pre><code class="language-python">
	# This is just a sample Python code block
	# demonstrating how code might be displayed.

	import numpy as np
	import matplotlib.pyplot as plt

	x = np.linspace(-10, 10, 100)
	y = 2*x + 5

	plt.plot(x, y)
	plt.title("Sample Plot")
	plt.show()
	</code></pre>






      </section>

      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
        <h2>Results &amp; Analysis</h2>
        <p>
After setup and initalizing the Turle graphics, Cell 2 uses random library, for the function random_walk a for loop calls the function random.uniform() to generate a floating point number between and including the lower bound and upper bound. I choose to begin with smaller numbers to interpret the vicual output scell and found steps = 30, step_length = 100 to give and easier to read and count and felt a clear understanding of the code based aon output. 
		
In the Blipline function, the first example of recursion is used in the code notebook. The function calls itself to mathematically reduce the size of the arguments passed to the next call. The recursive function has a built-in stop condition determined by the variable "order", which decrements with each recursive call until it reaches zero.

An if/else statement ensures that a straight line is drawn on the final function call. This is referred to as the base case, where the recursive function stops executing. If a base case is not included in future implementations, there is a potential risk of infinite recursion, leading to excessive resource consumption and possible processing errors depending on the platform's available resources.

Interestingly, this type of programming may have a correlation to denial-of-service (DoS) attacks in computer networking, where excessive recursive calls or loops overwhelm system resources.

For mental visualization, the recursive function could be rewritten using a for loop. In this case, recursion can be thought of as function calls acting similarly to loop iterations, with each recursive call being comparable to an execution of the loop, decrementing the "order" variable at each step.
The process is elevated to a third order and output visualization is understandable. Next the blip_line function is called in a new function named the kock_snowflake function. Added intot his function is a right turn of 120 degree which makes the order of 3 end up and the begining by 120 + 120 + 120 = 360 degrees. 
        </p>




        <figure>
          <img
            src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/21/Mandel_zoom_00_mandelbrot_set.jpg/800px-Mandel_zoom_00_mandelbrot_set.jpg"
            alt="Mandelbrot Broad View"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong>Figure 1:</strong> A broad view of the Mandelbrot set 
            (max_iter = 100). Colors represent how many iterations were 
            needed to exceed |z|=2.
          </figcaption>
        </figure>




      </section>



      <!-- CONCLUSION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
        <h2>Conclusion</h2>
        <p>
          In this sample conclusion, we highlight how the iterative approach to generating fractals reveals the vast complexity inherent in seemingly simple equations. Through our Python implementation, we observed that small parameter changes can produce markedly different fractal patterns, underscoring the Mandelbrot set's boundless intricacy. Our visualizations not only confirm the self-similarity and infinite resolution of the set, but also underscore the crucial role of computational optimizations in making high-resolution explorations feasible. Ultimately, this lab demonstrates that fractal geometry, far from being mere mathematical curiosities, provides deep insights into pattern formation and complexity in both pure mathematics and broader scientific contexts. 
        </p>
      </section>

     
     
     
   
     
     
     
  </main>

<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>
