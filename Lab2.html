<!-- INTRODUCTION SECTION -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<html>
<head> <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="stylesheet" href="https://latex.vercel.app/style.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css"/><script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]}};</script>

<title>Fractal Geometry Lab Report</title>

</head>
	
<body id="top">




  <header>
    <h1>Fractal Geometry Lab Report</h1>
    <p class="author">
      Joseph D Wilson <br />
      02/10/2025
    </p>
  </header>
  


  <main>
    <article class="indent-pars">
      
      <!-- INTRODUCTION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="introduction">
        <h2>Introduction</h2>
        <p>
          Lab 2 is for generating random walks called Brownian motion and implement Koch and dragon curves using Python Turtle graphics in a Google notebook environment.

        </p>
      </section>


     
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->


      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
     
	      <h3>a. Random Walks called Brownian motion</h3>
<p style="text-indent: 40px; line-height: 1.6;">
After setup and initalizing the Turle graphics, the random library is imported for the function random_walk. A for loop calls the function random.uniform() to generate a floating point number between and including the lower bound and upper bound. I choose to begin with smaller numbers to interpret the vicual output cell and found steps = 30, step_length = 100 to give and easier to read and count and felt a clear understanding of the code based on output. The code uses random for the degree of the turns. 
</p>		

<section id="code">
	<pre><code class="language-python">

    for _ in range(steps):
        forward(step_length)               # Move forward by the step length
        right(random.uniform(-180, 180))
		
	</code></pre>
<h4>b. Koch Curves</h4>

	
      </section>
<p style="text-indent: 40px; line-height: 1.6;">	      
In the Blipline function, the first example of recursion is used in the code notebook. The function calls itself to mathematically reduce the size of the arguments passed to the next call. The recursive function has a built-in stop condition determined by the variable "order", which decrements with each recursive call until it reaches zero.
</p>		
<p style="text-indent: 40px; line-height: 1.6;">
An if/else statement ensures that a straight line is drawn on the final function call. This is referred to as the base case, where the recursive function stops executing. If a base case is not included in future implementations, there is a potential risk of infinite recursion, leading to excessive resource consumption and possible processing errors depending on the platform's available resources.
</p>		
<p style="text-indent: 40px; line-height: 1.6;">
Interestingly, this type of programming may have a correlation to denial-of-service (DoS) attacks in computer networking, where excessive recursive calls or loops overwhelm system resources.
</p>		
<p style="text-indent: 40px; line-height: 1.6;">
The process is elevated to a third order and output visualization is understandable. Next the blip_line function is called in a new function named the kock_snowflake function. Added into his function is a right turn of 120 degree which makes the order of 3 end up and the begining by 120 + 120 + 120 = 360 degrees as shown in the figure below.  
        </p>




        <figure>
          <img
            src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/120degrees.jpg"
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Interpreting the 120 degrees right from code drawn onto the output cell. 
          </figcaption>
        </figure>

	      <p>
For another understadning of recursive function calls, the recursive function could have been rewritten using a for loop. In this case, recursion can be thought of as function calls acting similarly to loop iterations.  Each recursive call being comparable to an execution of the loop, decrementing the "order" variable at each step. Interpreting when the variable "order" and the recursive nature of the function has been drawn onto the output cell below. This would be one example of each so the overlap can be eaisly identified. 
	      </p>
        <figure>
          <img
            src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/variableOrder2.jpg"
            alt="cvariable order"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Segments highlighted of the variable "order". 
          </figcaption>
        </figure>
<p style="text-indent: 40px; line-height: 1.6;">
From the figure above, the table below will realate these sections to their value of the variables which are the order and lenth when the function is running. 
</p>
<!-- Insert Table Here -->
<table>
  <thead>
    <tr>
      <th>Segment</th>
      <th>Value of Order</th>
      <th>Value of length</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Segment 3</td>
      <td>      3</td>
      <td>    400/3</td>
         
    </tr>
    <tr>
      <td>Segment 2</td>
      <td>      2</td>
      <td>   (400/3)/3</td>
    </tr>
    <tr>
      <td>Segment 1</td>
      <td>      1</td>
      <td>  [(400/3)/3]/3</td>
    </tr>
    <tr>
      <td>Segment 0</td>
      <td>      0</td>
      <td>([(400/3)/3]/3)/3</td>
    </tr>
  </tbody>
</table>


	      <h5>c. Dragon Curves</h5>
      </section>



      <!-- CONCLUSION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
        <h6>Conclusion</h6>
        <p>
          In this sample conclusion, we highlight how the iterative approach to generating fractals reveals the vast complexity inherent in seemingly simple equations. Through our Python implementation, we observed that small parameter changes can produce markedly different fractal patterns, underscoring the Mandelbrot set's boundless intricacy. Our visualizations not only confirm the self-similarity and infinite resolution of the set, but also underscore the crucial role of computational optimizations in making high-resolution explorations feasible. Ultimately, this lab demonstrates that fractal geometry, far from being mere mathematical curiosities, provides deep insights into pattern formation and complexity in both pure mathematics and broader scientific contexts. 
        </p>
      </section>

     
     
     
   
     
     
     
  </main>

<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>
