<!-- INTRODUCTION SECTION -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- --> 
<!-- -------------------------------------------------------------------------------------------- -->
<html>
<head> <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="stylesheet" href="https://latex.vercel.app/style.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css"/><script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]}};</script>

<title>Fractal Geometry Lab Report 7/8</title>
</head>
<body id="top">
  <header>
    <h1>Fractal Geometry Lab Report 7 and 8</h1>
    <h1>    Mandelbrot and Julia Set</h1>
	  
    <p class="author">
      Joseph D Wilson <br />
      03/26/2025
    </p>
  </header>
  <main>
    <article class="indent-pars">
      
      <!-- INTRODUCTION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="introduction">
        <h2>Introduction: Mandelbrot and Julia Set Visualization</h2>
        <p>

		Fractal geometric patterns exhibit recursive patterns at adjustable scales. Two iconic examples of fractals are the Mandelbrot Set and Julia Set. Both are based on the iterative behavior of complex quadratic functions. In this lab, we explore these sets using Python and performance-optimized functions to generate high-resolution visualizations. By experimenting with constants, zoom levels, and colormaps, we gain insights into the complexity and beauty of these mathematical structures.
          
        </p>
      </section>


     
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->


      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
     
<h3>1. Mandelbrot Set Code Walkthrough</h3>

<p style="text-indent: 40px; line-height: 1.6;">
Creating definition of the function "mandelbrot(c, max_iter)" determines how complex numbers are being square and c is added. Many iterations it takes for a complex number z to "escape" beyond a radius of 2, under the iteration rule: z = z² + c. Also z and n are always begining at zero. 
This function returns the iteration count n, which is used to color each pixel.
        </p>

<pre><code class="language-python">
@jit(nopython=True)
def mandelbrot(c, max_iter):
    z = 0
    n = 0
    while abs(z) <= 2 and n < max_iter:
        z = z*z + c
        n += 1
    return n
</code></pre>
	      
<p style="text-indent: 40px; line-height: 1.6;">
 The next function definition, or declaration, "mandelbrot_set(...)" generates the entire Mandelbrot set by iterating over a grid of complex numbers and calling mandelbrot() for each.
The function uses input of the grid boundaries (xmin, xmax, etc.), resolution (width, height), and max iteration count. The function returns a 2D array n3 representing the escape-time values for visualization. This function alse creates the complex set with the real portion "i" and the imginary square root of negative one as "j". 
</p>

	    <pre><code class="language-python">
@jit(nopython=True)
def mandelbrot_set(xmin, xmax, ymin, ymax, width, height, max_iter):
    r1 = np.linspace(xmin, xmax, width)
    r2 = np.linspace(ymin, ymax, height)
    n3 = np.empty((width, height))

    for i in range(width):
        for j in range(height):
            n3[i, j] = mandelbrot(r1[i] + 1j * r2[j], max_iter)

    return n3
</code></pre>
	    
<p style="text-indent: 40px; line-height: 1.6;">
The table below illustrates the behavior of key variables during the first 10 iterations of the Mandelbrot function. Each complex value represents a coordinate on the complex plane, which is visualized in the fractal plot. The magnitude of each complex number is calculated using the formula:

|z| = sqrt(a² + b²)

This magnitude, shown in the table as |z|, is essential for determining whether the iterative sequence escapes or remains bounded.

In engineering, complex numbers are commonly expressed as a + bi, where b corresponds to the imaginary part—often interpreted as the "y-axis" on the complex plane. This imaginary component is especially important in applications like AC circuit analysis, where it represents phase differences in alternating signals. Evaluating the magnitude of complex impedance is a key step in impedance matching, which is critical for maximizing power transfer in electrical systems.
 </p>
	    
<table>
  <thead>
    <tr>
      <th>Iteration (n)</th>
      <th>z<sub>n</sub> (Complex Value)</th>
      <th>|z<sub>n</sub>|</th>
      <th>Explanation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>0</td>
      <td>0.000</td>
      <td>Start at 0</td>
    </tr>
    <tr>
      <td>1</td>
      <td>-0.75 + 0.1j</td>
      <td>0.757</td>
      <td>First step adds c</td>
    </tr>
    <tr>
      <td>2</td>
      <td>0.5225 - 0.15j</td>
      <td>0.543</td>
      <td>Now squaring and adding again</td>
    </tr>
    <tr>
      <td>3</td>
      <td>-0.5086 - 0.0567j</td>
      <td>0.511</td>
      <td>Back into negative real territory</td>
    </tr>
    <tr>
      <td>4</td>
      <td>-0.5092 + 0.1576j</td>
      <td>0.533</td>
      <td>Real bouncing, imaginary increasing</td>
    </tr>
    <tr>
      <td>5</td>
      <td>-0.2343 - 0.0607j</td>
      <td>0.242</td>
      <td>Now smaller in magnitude again</td>
    </tr>
    <tr>
      <td>6</td>
      <td>-0.8057 + 0.1285j</td>
      <td>0.816</td>
      <td>Real dips further negative</td>
    </tr>
    <tr>
      <td>7</td>
      <td>-0.2284 - 0.1073j</td>
      <td>0.252</td>
      <td>Starts looping again</td>
    </tr>
    <tr>
      <td>8</td>
      <td>-0.7939 + 0.1490j</td>
      <td>0.807</td>
      <td>Still bounded (&lt; 2)</td>
    </tr>
    <tr>
      <td>9</td>
      <td>-0.2624 - 0.1362j</td>
      <td>0.296</td>
      <td>Continues inside set</td>
    </tr>
  </tbody>
</table>



	    

	    
<p style="text-indent: 40px; line-height: 1.6;">
Next, the variables, or arguments, are set. 
</p>
	    
<pre><code class="language-python">
xmin, xmax, ymin, ymax = -2.0, 1.0, -1.5, 1.5
width, height = 800, 800
max_iter = 100
</code></pre>

<p style="text-indent: 40px; line-height: 1.6;">
Now the codes gets a little unclear as to the intentions, a mandlebrot set is created with the parameters we have already created, then thos parameters are altered and the same funnction call, creates a mandelbrot set, again as "n3". The last part of this setion is the plotting image below. 
</p>

<pre><code class="language-python">
 xmin, xmax, ymin, ymax = -0.75, -0.74, 0.1, 0.11  # Zoom into this specific area
width, height = 800, 800  # Resolution of the image
max_iter = 1000  # Number of iterations

# Generate the Mandelbrot Set with zoom
n3 = mandelbrot_set(xmin, xmax, ymin, ymax, width, height, max_iter)

# Plotting the zoomed Mandelbrot Set
plt.figure(figsize=(10, 10))
plt.imshow(n3.T, extent=[xmin, xmax, ymin, ymax], cmap='hot')
plt.colorbar()
plt.title("Mandelbrot Set - Zoomed In")
plt.show()
</code></pre>

<figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/lab78a.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> The plot of Mandelbrot Set
          </figcaption>
</figure>


 <h3>2. Julia Set Code Walkthrough</h3>
<p style="text-indent: 40px; line-height: 1.6;">
Our third function julia_set(c, ...) generates the Julia set for a fixed complex constant c. The julia set process is similar to Mandelbrot, but each point starts with z = pixel_value and applies z = z² + c with constant c. The key difference is the constant c is fixed for Julia, while it's the pixel value in Mandelbrot. Different constants c drastically alter the shape of the Julia set.
</p>	  
	    
<pre><code class="language-python">
def julia_set(c, xmin, xmax, ymin, ymax, width, height, max_iter):
    r1 = np.linspace(xmin, xmax, width)
    r2 = np.linspace(ymin, ymax, height)
    n3 = np.empty((width, height))

    for i in range(width):
        for j in range(height):
            z = r1[i] + 1j * r2[j]
            n = 0
            while abs(z) <= 2 and n < max_iter:
                z = z*z + c
                n += 1
            n3[i, j] = n

    return n3
</code></pre>

 
   
<p style="text-indent: 40px; line-height: 1.6;">
 
        </p>	    
	      
        <figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/lab78b.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> The zoom into the fuinction Mandlebrot
          </figcaption>
        </figure>

<h3>Julia Set </h3>
	      
<p style="text-indent: 40px; line-height: 1.6;">
The next code applies iterative transformation where the grid points are mapped with complex plane. Here a new variable is sent to the function for iterations, a condition of a for loop where the transformation is  asquare and then subtracting one half. The function returns both real and imaginary values. With the interations set to one, the grib begins to distortas shown below.  As a non linear structure the slop is not constant, this is visually exposed in the plot. 
 </p>	 

<pre><code class="language-python">
def iterative_transform(grid, iterations):
    x_grid, y_grid = grid
    z = x_grid + 1j * y_grid  # Create a complex plane
    for i in range(iterations):
        z = z ** 2 - 0.5  # Iteratively apply the transformation
    return np.real(z), np.imag(z)

# Set the number of iterations
iterations = 1

# Apply the iterative transformation
fractal_grid = iterative_transform(grid, iterations)

# Plot the fractal grid
plot_grid(fractal_grid)
</code></pre>


        <figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/Lab06b.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> The nonlineasr transformation of grid with 1 iterations
          </figcaption>
        </figure>

	      
	      
<p style="text-indent: 40px; line-height: 1.6;">
When making changes to this function variable, it should be notes that this function runs from the grid created previously and changes there can be reset, back to 50, to intrepret current transformation more clearly. after resetting the plot and changing iteration to iterations = 2, the increase of iteration causes more depth in transformation. The shpaes begin to show signs from the squaring of the complex number, this begins fractal behavior.	
</p>		

<pre><code class="language-python">
# Set the number of iterations
iterations = 2
</code></pre>
	              <figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/Lab06b2.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> The nonlineasr transformation of grid with 2 iterations
          </figcaption>
        </figure>
	      
	      
	      
<p style="text-indent: 40px; line-height: 1.6;">
The remaining code adjustments still show signs of visually appealing mathimatical curves where you could almost connect the dots to follow shapes.  
</p>		
	      
<pre><code class="language-python">
# Set the number of iterations
iterations = 3

# Apply the iterative transformation
fractal_grid = iterative_transform(grid, iterations)

# Plot the fractal grid
plot_grid(fractal_grid)
</code></pre>	 

        	    


        <figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/Lab06c.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> The transformation with iteration as 3
          </figcaption>
        </figure>

<h3>Changes in Grid Size</h3>
	      
<p style="text-indent: 40px; line-height: 1.6;">
By changing the grid from 50 to 100, the trasnformations allow us to interpret the samples on a higher depth rate. Notice to the overlap in the iteration = 2 plot reveals a new patter that gives a a great pattern below  
 
</p>
        <figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/Lab06d.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> The 100 by 100 grid 
          </figcaption>
        </figure>
	      
        <figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/Lab06e.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> The 100 by 100 grid transformation with iteration as 2
          </figcaption>
        </figure>


<h3>Experiment with different transformations</h3>
<p style="text-indent: 40px; line-height: 1.6;">
By changing the transformation, additional visualization can give patterns to complex math functions. 
</p>
	      
<pre><code class="language-python">
       z = z ** 3 - 0.5  # Iteratively apply the transformation
</code></pre>
	      
       <figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/Lab06f.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> The alternative transformation cubed
          </figcaption>
        </figure>

<p style="text-indent: 40px; line-height: 1.6;">
Additional transformation can reveal new patterns using sin in place of imaginary i. 
</p>
	      
<pre><code class="language-python">
        z = np.sin(z) + 1j * np.cos(z)   # Iteratively apply the transformation
</code></pre>
	      
        <figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/Lab06g.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> The alternative transformation 2
          </figcaption>
        </figure>

	      <pre><code class="language-python">
def iterative_transform(grid, iterations):
    x_grid, y_grid = grid
    z = x_grid + 1j * y_grid  # Create a complex plane
    for i in range(iterations):
        z = np.sin(z) + 1j * np.cos(z)   # Iteratively apply the transformation
    return np.real(z), np.imag(z)

# Set the number of iterations
iterations = 2
</code></pre>
	      
        <figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/Lab06h.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> The alternative transformation with iteration 2 
          </figcaption>
        </figure>


	    
	    <!-- CONCLUSION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
        <h6>Conclusion</h6>
        <p>
In this lab, a simple 2D grid is transformed into visual patterns using complex number arithmetic and iterative functions. The applied transformation involves squaring a complex number and subtracting half of its real part—a process that leads to fractal formation when repeated. NumPy performs computations in the complex plane, while Matplotlib visualizes the results. Alterations to the grid size and transformation rules can change the visual output, enabling the generation of an unlimited variety of complex patterns. By combining basic programming with abstract mathematical concepts, we are able to analyze phenomena that were previously difficult to represent or understand. Here iteration was kept low, in some of the higher iterations tried, the plot lost large amount points, this may need to be evualated in a 3D environment for a better understanding. 

        </p>
      </section>

  </main>

<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>
