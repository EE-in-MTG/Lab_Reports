<!-- INTRODUCTION SECTION -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<html>
<head> <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="stylesheet" href="https://latex.vercel.app/style.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css"/><script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]}};</script>

<title>Fractal Geometry Lab Report 4 Fractal Trees</title>

</head>
	
<body id="top">




  <header>
    <h1>Fractal Geometry Lab Report 4 Trees</h1>
	  
    <p class="author">
      Joseph D Wilson <br />
      03/08/2025
    </p>
  </header>
  


  <main>
    <article class="indent-pars">
      
      <!-- INTRODUCTION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="introduction">
        <h2>Introduction</h2>
        <p>
This report explores the concept of fractal trees, a recursive geometric structure that mimics natural branching patterns and exhibits self-similarity at various scales. Using Turtle Graphics, a program is implemented to generate a fractal tree by recursively splitting branches into smaller sub-branches at a fixed angle and scale. Fractal trees serve as a fundamental example of recursion in geometry, where each branch continuously divides following a defined pattern. By applying recursive algorithms, this study demonstrates how fractal trees model naturally occurring structures such as trees, rivers, and lightning bolts. These clostly relate to the flowers "baby's breath" and dandelions. A base case is assigned to control recursion and prevent infinite branching. The goal of this report is to analyze the implementation of fractal trees, understand the role of recursion in their formation, and explore their significance in computational geometry, computer graphics, and natural simulations.
          
        </p>
      </section>


     
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->


      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
     
	      <h3>a. Recursively draw fractal trees</h3>
<p style="text-indent: 40px; line-height: 1.6;">
This lab begins by defining a function, fractal_tree with the lenth and depth parameters. When the tree is in the output, the first impression is to count how many branches, this is always the same amount and is equal to the variable depth. 
        </p>

<pre><code class="language-python">
# Function to draw a fractal tree using recursion
def fractal_tree(length, depth):
    if depth == 0:
        return
    else:
        forward(length)
        left(30)

        fractal_tree(length * 0.7, depth - 1)

        right(60)

        fractal_tree(length * 0.7, depth - 1)

        left(30)
        backward(length)
</code></pre>
	      
<p style="text-indent: 40px; line-height: 1.6;">
The function "fractal_tree" generates a fractal structure using two parameters: length and depth. The pen down approach to Turtle graphics makes the forward a draw method of the function.  The "depth" variable determines the length of the current branch, and depth, which controls the number of recursive levels. The complexity of the tree is based on the number of these levels. The function begins by checking if the depth has reached the base case of zero; if so, it terminates. If the base case is not met, the function moves the turtle forward by the given length to draw the main trunk. The turtle then turns 30 degrees to the left and calls the function recursively to create the left sub-branch at 70% of the original length.

After completing the left branch, the turtle turns 60 degrees to the right, effectively shifting 30 degrees to the right from the original position, and then calls the function again to create the right sub-branch. Once both branches are drawn, the turtle turns back left by 30 degrees and moves backward to its previous position, ensuring that recursion maintains a structured branching pattern. This return to the starting position is key to the tree’s structure; it is not just a fractal infinitely spiraling inward. Instead, this pattern follows a linear movement, with each depth level crossing a defined space.

At each branching point, the tree recursively splits into two smaller branches at fixed angles, creating a symmetric structure. The recursive nature of the function mirrors the growth patterns found in real trees, where smaller branches emerge from larger ones in a self-similar fashion. The use of left and right turns ensures that each split follows a predictable pattern, preventing the fractal from becoming asymmetrical.

If this tree were extended into three dimensions, additional angles of rotation  as  branches move up or down in the Z axis.  The current implementation provides a simple yet two-dimensional space while offering potential extensions into more complex regions. In linear algebra, we are taught that mathematical principles in two and three dimensions can be extended to higher dimensions. However, as humans, we struggle to intuitively grasp a 20-dimensional dataset or matrix. If the fourth dimension is time, then features such as color or other visual attributes could potentially be used to express complex data in a geometric representation.
</p>		
<pre><code class="language-python">
# Initialize the turtle
initializeTurtle(initial_window_size=(500, 500))

# Set up the turtle's starting position and orientation
jump(250, 450)  # Starting position at the bottom center of the canvas
face(0)
color('green')  # Set the pen color

# Set the length and depth for the fractal tree
length = 100  # Initial length of the main trunk
depth = 7     # Recursion depth (number of branching levels)

# Draw the fractal tree
fractal_tree(length, depth)

# Display the drawing
show()
</code></pre>	
	      
<p style="text-indent: 40px; line-height: 1.6;">
The inclusion of backward allows multiple triangles to be nested within the outer triangles. The concept of order and recursion ensures that the smallest inner triangles are drawn at order zero. The table below compares the values of the variables order and length. Based on the table and the code, a triangle is only drawn when length reaches 25, which is the smallest calculated length.	
</p>

	      	    


<p style="text-indent: 40px; line-height: 1.6;">
The image below illustrates how the tree has a left and a right to each stem, there fore gaining exponential in base 2. The calcuation for bits can be used for max terms, 2, 4, 8, 16, 32, 64 and so on. 
</p>	

        <figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/Lab4_2.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> First Tree with depth 7 
          </figcaption>
        </figure>

<p style="text-indent: 40px; line-height: 1.6;">
In the next section the tree is build with a different function, where the base case of 0 quits the function before, now the comparison to greater than 3 is involved. 
</p>

	
	    
<pre><code class="language-python">
# Define the fractal tree function
def build_tree(branch_length, shorten_by, angle):
    if branch_length > 3:

        forward(branch_length)

        new_length = branch_length - shorten_by

        left(angle)

        build_tree(new_length, shorten_by, angle)

        right(angle * 2)

        build_tree(new_length, shorten_by, angle)

        left(angle)

        backward(branch_length)
</code></pre>

	    
<p style="text-indent: 40px; line-height: 1.6;">
TEXT1
</p>		

	      <p style="text-indent: 40px; line-height: 1.6;">
The image below illustrates how the tree has a left and a right to each stem, there fore gaining exponential in base 2. The calcuation for bits can be used for max terms, 2, 4, 8, 16, 32, 64 and so on. 
</p>	

        <figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/Lab4_1.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> First Tree with depth 7 
          </figcaption>
        </figure>
	      
<p style="text-indent: 40px; line-height: 1.6;">
Text 2 
</p>
	    
<p style="text-indent: 40px; line-height: 1.6;">
Text3
	
<!-- Insert Table Here -->
<table>
  <thead>
    <tr>
      <th>row</th>
      <th>values in row</th>
      
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>	00000000000000000000000000000100000000000000000000000</td>
         
    </tr>
    <tr>
      <td>1</td>
      <td>      00000000000000000000000000001010000000000000000000000</td>
    </tr>
    <tr>
      <td>2</td>
      <td>      00000000000000000000000000010101000000000000000000000</td>
    </tr>
    <tr>
      <td>3</td>
      <td>      	00000000000000000000000000101010100000000000000000000</td>
    </tr>
  </tbody>
</table>

<p>
The table illustrates the beginning of the Sierpiński Triangle, showing how the pattern starts to form. As the rule is applied iteratively, the triangular fractal structure continues to expand throughout the image output below.

Each subsequent row follows the recursive rule, creating a self-similar pattern that grows symmetrically based on the binary rule logic.
</p>
        <figure>
          <img
            src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/L3rule1.jpg"
            alt="cvariable order"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> The image above helps to express the top rows value provide in table above. 
          </figcaption>
        </figure>
<p style="text-indent: 40px; line-height: 1.6;">
The image displayed in the output cell represents the shape generated by the applied rule. This specific rule is known as Rule 90. The Sierpiński triangle emerges due to the behavior of the Exclusive OR (XOR) logic gate, meaning that a cell is activated (1) only when exactly one of its two neighboring cells from the row above is active.

Rule 90 belongs to the class of additive elementary cellular automata [1], where the next state of each cell is determined by a simple binary addition modulo 2 (XOR operation). This results in the characteristic fractal-like, self-similar pattern seen in the output.
</p>

<p style="text-indent: 40px; line-height: 1.6;">
The next section introduces an alternative approach to implementing the cellular automaton. Instead of using a 3D array as a lookup table, this version utilizes a formula to achieve the same outcome.

The formula used is: 
	$$ X[i, j] = (rule / (2**(4*X[i-1,j-1] + 2*X[i-1,j] + X[i-1,j+1]))) % 2 $$ 

This formula calculates the output based on the current values of i and j (or m and n, representing rows and columns) in the previous row.This approach is mathematically equivalent to using a lookup table, as the modulus operation ensures that only the relevant rule bit is used in determining the cell's state.
</p>
<p style="text-indent: 40px; line-height: 1.6;">    
	The previous setup of mathimatical generations is finally altered by changeing the value of the variable "rule". 
</p>
<pre><code class="language-python">
for rule in [30, 62, 90, 110, 126]:
    plot(CA(C))
</code></pre>
<p style="text-indent: 40px; line-height: 1.6;">    
The for loop iterates through different values of rule, applying the CA (cellular automaton) function and plotting the results.

Rule 30 is classified as chaotic and was of special interest to Stephen Wolfram. It has been studied for its random-like behavior and can even be used as a random number generator [2].
Rule 62 is another elementary cellular automaton that determines the next state based on previous neighbors. It is also the mirror image of Rule 118 [3]. The asymmetrical output appears with a diagonal structure on the left side of the screen, while the right side exhibits horizontal repeating patterns.
Rule 90 generates the Sierpiński Triangle, as described earlier.
Rule 110 follows the same process and has a binary representation of 110 = 01101110 (calculated as 64 + 32 + 8 + 4 + 2 = 110) [4]. An interesting observation is that the left half of the screen is populated, while the right half remains empty.
Rule 126 is classified as amphichiral [5]. This means it is superposable with its mirror image, meaning the pattern remains unchanged when reflected [6].
</p>	     

<!-- Insert Table Here -->
<table>
  <thead>
    <tr>
      <th>Wolfram Rule</th>
      <th>ouput</th>
     
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>30</td>
      <td>chaotic pattern</td>   
    </tr>
    <tr>
      <td>62</td>
      <td>    more stucture </td>
     
    </tr>
    <tr>
      <td>90</td>
      <td> Sierpinski Triangle</td>
     
    </tr>
    <tr>
      <td>110</td>
      <td>      left ouput only</td>
      
    </tr>
	<tr>
      <td>126</td>
      <td>      amphichiral</td>
    </tr>
  </tbody>
</table>
	    
	    <!-- CONCLUSION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
        <h6>Conclusion</h6>
        <p>
          This lab the implements and visualizes elementary cellular automata using Python. The focus of labs include recursive structures, bitwise operations, and rule-based pattern generation, particularly in the context of the Sierpiński Triangle and numerical bitwise based Wolfram rules.

The first section introduced recursion through the sierpinski_triangle function, which used recursion to create equilateral triangles patterns. The relationship between recursion depth  variable "order" and the number of smaller triangles drawn was analyzed to show how recursion increases exponentially.

The second part of the lab introduced cellular automata with a 100 × 100 array initalized with a single 1 at (0,50) and the remaining all zeros. Using Rule 90, the well-known Sierpiński Triangle was generated based on Exclusive OR, XOR logic, where a cell becomes active if only one of its two neighboring cells is active. After using a lookup tables,a mathematical operation was used to complete the same task for the Sierpiński Triangle, both ways created the same output cell.

The final section expanded upon elementary cellular automata, comparing several different Wolfram rules.

Rule 30, noted for its chaotic behavior, has potential applications in random number generation.
Rule 62, a mirror image of Rule 118, exhibited asymmetrical diagonal patterns with repeating structures.
Rule 90, forming the Sierpiński Triangle, displayed a predictable self-similar fractal.
Rule 110, Turing complete, showcased computational complexity where one half of the grid became populated while the other remained empty.
Rule 126, identified as amphichiral, demonstrated symmetry in its mirrored output.
Through this lab binary rules created complex patterns by mathematical logic and recursion in Python software functions. 


        </p>
      </section>

     
  <h6>reference</h6>   
           <p>
     [1] Rule 30. from Wolfram MathWorld. (n.d.). https://mathworld.wolfram.com/Rule30.html 
            </p>
	<p>
     [2] Rule 62. from Wolfram MathWorld. (n.d.). https://mathworld.wolfram.com/Rule62.html 
            </p>
             <p>
     [3] Rule 90. from Wolfram MathWorld. (n.d.). https://mathworld.wolfram.com/Rule90.html 
            </p>
	<p>
     [4] Rule 110. from Wolfram MathWorld. (n.d.). https://mathworld.wolfram.com/Rule110.html 
            </p>   
	    	<p>
     [5] Rule 126. from Wolfram MathWorld. (n.d.). https://mathworld.wolfram.com/Rule126.html 
            </p>   
<p>
[6] Amphichiral. from Wolfram MathWorld. (n.d.). https://mathworld.wolfram.com/Amphichiral.html
	 </p> 
  </main>

<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>
