<!-- INTRODUCTION SECTION -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- --> 
<!-- -------------------------------------------------------------------------------------------- -->
<html>
<head> <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="stylesheet" href="https://latex.vercel.app/style.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css"/><script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]}};</script>

<title>Fractal Geometry Lab Report 9</title>
</head>
<body id="top">
  <header>
    <h1>Fractal Geometry Lab Report 9</h1>
    <h1>    Fractals and L-Systems</h1>
	  
    <p class="author">
      Joseph D Wilson <br />
      04/27/2025
    </p>
  </header>
  <main>
    <article class="indent-pars">
      
      <!-- INTRODUCTION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="introduction">
        <h2>Introduction: Mandelbrot and Julia Set Visualization</h2>
        <p>

This lab explores fractals and recursive pattern computation methods including the Chaos Game, Iterated Function Systems for the Barnsley Fern, and L-Systems to generate plant-like structures and space-filling curves such as the Hilbert Curve. We analyze, modify, and extend the code to enhance visual outcomes and explore novel fractal variants.
          
        </p>
      </section>


     
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->


      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
     
<h3>1. The Sierpinski Triangle via the Chaos Game</h3>

<p style="text-indent: 40px; line-height: 1.6;">
The original code randomly selects one of three triangle vertices, computes the midpoint between the current point and the selected vertex, and iterates this process to generate points converging on the Sierpinski Triangle.  
        </p>

<figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/lab9a.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Original 
          </figcaption>
</figure>

<p style="text-indent: 40px; line-height: 1.6;">
A modification for this would be adding color gradient to represent iteration progression as a representation of the time domain.Another modification can be on the shape of the triagnles, an option to change triangle shape scalene or isosceles can change the basic element fo the structure. The shape of the triangle can dramatically influence the overall pattern aesthetics. Color mapping iterations improves visual insight into convergence.
        </p>

<pre><code class="language-python">
@jit(nopython=True)
def mandelbrot(c, max_iter):
    z = 0
    n = 0
    while abs(z) <= 2 and n < max_iter:
        z = z*z + c
        n += 1
    return n
</code></pre>
	      
<p style="text-indent: 40px; line-height: 1.6;">
 The next function definition, or declaration, "mandelbrot_set(...)" generates the entire Mandelbrot set by iterating over a grid of complex numbers and calling mandelbrot() for each.
The function uses input of the grid boundaries (xmin, xmax, etc.), resolution (width, height), and max iteration count. The function returns a 2D array n3 representing the escape-time values for visualization. This function alse creates the complex set with the real portion "i" and the imginary square root of negative one as "j". 
</p>

	    <pre><code class="language-python">
@jit(nopython=True)
def mandelbrot_set(xmin, xmax, ymin, ymax, width, height, max_iter):
    r1 = np.linspace(xmin, xmax, width)
    r2 = np.linspace(ymin, ymax, height)
    n3 = np.empty((width, height))

    for i in range(width):
        for j in range(height):
            n3[i, j] = mandelbrot(r1[i] + 1j * r2[j], max_iter)

    return n3
</code></pre>

	    <figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/lab9a1.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Modification
          </figcaption>
</figure>
	    
<h3>2. Barnsley Fern (Iterated Function System)</h3>	    
	    
<p style="text-indent: 40px; line-height: 1.6;">
Code uses four affine transformations with assigned probabilities and generates a self-similar Barnsley Fern.

 </p>

<figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/lab9b.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Original 
          </figcaption>
</figure>

<p style="text-indent: 40px; line-height: 1.6;">
 Code modifications use color mapping based on height/y-values and variation of the Barnsley Maple by modified coefficients.
 </p>

<pre><code class="language-python">
# Modified: Color based on y-value for height effect
x_vals, y_vals = zip(*fern_points)
colors = np.array(y_vals)

plt.figure(figsize=(6, 10))
plt.scatter(x_vals, y_vals, c=colors, cmap='summer', s=0.1)
plt.title('Barnsley Fern with Height-based Color')
plt.show()

# New: Maple-style variant of Barnsley Fern
def barnsley_maple(iterations):
    x, y = 0, 0
    points = []
    for _ in range(iterations):
        rand = random.random()
        if rand < 0.02:
            x, y = 0, 0.25 * y
        elif rand < 0.84:
            x, y = 0.85 * x + 0.02 * y, -0.02 * x + 0.85 * y + 1.6
        elif rand < 0.92:
            x, y = 0.2 * x - 0.31 * y, 0.255 * x + 0.245 * y + 0.29
        else:
            x, y = -0.25 * x + 0.28 * y, 0.26 * x + 0.24 * y + 0.44
        points.append((x, y))
    return points

maple_points = barnsley_maple(iterations)
x_maple, y_maple = zip(*maple_points)

plt.figure(figsize=(6, 10))
plt.scatter(x_maple, y_maple, s=0.1, color='darkred')
plt.title('Barnsley Maple Variant')
plt.show()

</code></pre>
	    
<figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/lab9b1.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Modification
          </figcaption>
</figure>

	    
<h3>2. Barnsley Fern (Iterated Function System)</h3>	



<p style="text-indent: 40px; line-height: 1.6;">
Uses recursive rules to simulate branching patterns.

Classic fractal tree model. 
</p>

<figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/lab9c.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Original
          </figcaption>
</figure>


	    


<p style="text-indent: 40px; line-height: 1.6;">
Added randomness to angle and length for a more natural look.

Customizable depth and angle.

Randomized trees mimic natural growth more closely, enhancing realism over strictly deterministic fractals.
</p>


	    
<pre><code class="language-python">
	
# Randomized tree-like fractal
import turtle
import random

turtle.speed(0)
turtle.hideturtle()
turtle.bgcolor("black")
turtle.color("lime")

def draw_branch(branch_length, t):
    if branch_length > 5:
        angle = random.randint(20, 40)
        length_factor = random.uniform(0.6, 0.8)

        t.forward(branch_length)
        t.left(angle)
        draw_branch(branch_length * length_factor, t)
        t.right(angle * 2)
        draw_branch(branch_length * length_factor, t)
        t.left(angle)
        t.backward(branch_length)

# Initial call
turtle.left(90)
turtle.penup()
turtle.goto(0, -250)
turtle.pendown()
draw_branch(100, turtle)
turtle.done()

</code></pre>

<figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/lab9c1.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Modification
          </figcaption>
</figure>


	    
<h3> Alterations to the Mandelbrot Set </h3>
<p style="text-indent: 40px; line-height: 1.6;">
 An alteration for the Mandelbrot available in Python is to change the color map from the original hot to plasma or inferno.
</p>	
<pre><code class="language-python">
 plt.imshow(n3.T, extent=[xmin, xmax, ymin, ymax], cmap='plasma')	
</code></pre>	    
 	    
	      
<figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/lab78f.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Mandlebrot colormap plasma
          </figcaption>
</figure>

	    

<figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/lab78g.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Mandlebrot colormap inferno
          </figcaption>
        </figure>

<p style="text-indent: 40px; line-height: 1.6;">
 Another alteration for the Mandelbrot is to alter colormap.
</p>	
	    
<pre><code class="language-python">
  while abs(z) <= 2 and n < max_iter: 	
</code></pre>
<p style="text-indent: 40px; line-height: 1.6;">
 wg=hen changing 2 to 1
</p>		
<pre><code class="language-python">
  while abs(z) <= 1 and n < max_iter: 	
</code></pre>
<figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/lab78j.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Mandlebrot alteration to while abs(z) <= 1
          </figcaption>
        </figure>

 		     

 <h3>2. Julia Set Code Walkthrough</h3>


	    
<p style="text-indent: 40px; line-height: 1.6;">
Our third function julia_set(c, ...) generates the Julia set for a fixed complex constant c. The julia set process is similar to Mandelbrot, but each point starts with z = pixel_value and applies z = z² + c with constant c. Unlike the Mandelbrot Set where z starts at 0 and c varies,  the constant c is fixed for Julia and z varies across each pixel in the complex plane.  Different constants c alter the shape of the Julia set.
</p>	  
	    
<pre><code class="language-python">
def julia_set(c, xmin, xmax, ymin, ymax, width, height, max_iter):
    r1 = np.linspace(xmin, xmax, width)
    r2 = np.linspace(ymin, ymax, height)
    n3 = np.empty((width, height))

    for i in range(width):
        for j in range(height):
            z = r1[i] + 1j * r2[j]
            n = 0
            while abs(z) <= 2 and n < max_iter:
                z = z*z + c
                n += 1
            n3[i, j] = n

    return n3
</code></pre>

 
   
<p style="text-indent: 40px; line-height: 1.6;">
 
</p>	    
	      
        <figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/lab78b.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> The zoom into the fuinction Mandlebrot
          </figcaption>
        </figure>

<h3> Alterations to the Julia Set </h3>

<p style="text-indent: 40px; line-height: 1.6;">
Alterations to the Julia set can be done by changing the C value, the original -0.8 + j 0.156 Python code below is altered and plotting image below. 
</p>

<p style="text-indent: 40px; line-height: 1.6;">
The Original code 
</p>
<pre><code class="language-python">
c = complex(-0.8, 0.156)
</code></pre>

<p style="text-indent: 40px; line-height: 1.6;">
The first alteration code where c = -0.4 + 0.6j
</p>
<pre><code class="language-python">
c = complex(-0.4, 0.6)
</code></pre>
	    
        <figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/lab78c.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> alterations to the Madelbrot : c = complex(-0.4, 0.6)
          </figcaption>
        </figure>


<p style="text-indent: 40px; line-height: 1.6;">
The next alteration code where c = 0.285 + 0.01j
</p>
		    
<pre><code class="language-python">
c = complex(0.285, 0.01)
</code></pre>
		    
<figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/lab78d.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> alterations to the Julia Set c = complex(0.285, 0.01)
          </figcaption>
</figure>
		    
<p style="text-indent: 40px; line-height: 1.6;">
The next alteration code where c = 0 + 1j
</p>
<pre><code class="language-python">
c = complex(0, 1)
</code></pre>	      
	      
<figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/lab78e.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Alterations to the Julia Set c = complex(0, 1)
          </figcaption>
        </figure>


		    


		    


	    
	    <!-- CONCLUSION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
        <h6>Conclusion</h6>
        <p>

		
The Mandelbrot and Julia Sets highlight the connection between mathematics and complex numbers. Both sets are based on the recursive formula 
𝑧
=
𝑧
2
+
𝑐
z=z 
2
 +c, yet they generate entirely different behaviors depending on whether the constant 
𝑐
c is fixed (Julia) or varies across the complex plane (Mandelbrot). The Mandelbrot Set acts as a map that classifies which complex values of 
𝑐
c lead to stable or chaotic patterns, while each point within it defines a unique Julia Set with its own structure. Through visualization, zooming, and experimentation with constants and color maps, we were able to uncover intricate patterns that demonstrate nonlinear systems. These fractals reinforce concepts in complex iteration and aid to understanding the theory, mathematical modeling, and digital plotting in fractal geometery.


		

        </p>
      </section>

  </main>

<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>
