<!-- INTRODUCTION SECTION -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- --> 
<!-- -------------------------------------------------------------------------------------------- -->
<html>
<head> <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="stylesheet" href="https://latex.vercel.app/style.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css"/><script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]}};</script>

<title>Fractal Geometry Lab Report 9</title>
</head>
<body id="top">
  <header>
    <h1>Fractal Geometry Lab Report 9</h1>
    <h1>    Fractals and L-Systems</h1>
	  
    <p class="author">
      Joseph D Wilson <br />
      04/27/2025
    </p>
  </header>
  <main>
    <article class="indent-pars">
      
      <!-- INTRODUCTION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="introduction">
        <h2>Introduction</h2>
        <p>

This lab explores fractals and recursive pattern computation methods including the Chaos Game, Iterated Function Systems for the Barnsley Fern, and L-Systems. These fractals generate visually plant-like structures and space-filling curves such as the Hilbert Curve. We analyze, modify, and extend the code to enhance visual outcomes and explore modifications to fractal environments.
          
        </p>
      </section>
 
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->

      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
<h3>1. The Sierpinski Triangle via the Chaos Game</h3>

<p style="text-indent: 40px; line-height: 1.6;">
The original code randomly selects one of three triangle vertices, computes the midpoint between the current point and the selected vertex, and iterates this process to generate points converging on the Sierpinski Triangle.  
 </p>
<p style="text-indent: 40px; line-height: 1.6;">
The Chaos Game repeatedly moves halfway between the current point and a random triangle vertex.
 The code first creates a function “midpoint”, this function takes two points P=(x1,y1) and Q=(x2,y2), then calculates the midpoint formula M=((x1+x2)/2,(y1+y2)/2)and returns the midpoint between them. 
Next, the code creates a list equivalent of an equilateral triangle vertices. The list holds three tuples, which represent an XY point in a 2-dimensional plane. This gives shape of always being “bottom left”, “top”, and “bottom right” and restricts rotation, locking the 2D orientation of each triangle like grid. 
 </p>
<pre><code class="language-python">
vertices = [(0, 0), (2, 2*np.sqrt(3)), (4, 0)]
</code></pre>

<p style="text-indent: 40px; line-height: 1.6;">
The software creates two lists, using a variable iterations for the length of the lists X and Y. When created, they are filled with zeros. If the variable iterations = five, then the lists would look like the code output below. 
 </p>
<pre><code class="language-python">
x = [0, 0, 0, 0, 0]
y = [0, 0, 0, 0, 0]
</code></pre>
	      
<p style="text-indent: 40px; line-height: 1.6;">

This list works together to store the points that are created on the 2D plane. They are calculated in a for loop, with the length of iterations, by the midpoint function. So the concept is if you randomly take 1 of 3 ends of a triangle and record the midpoint, then continuing your recording will produce the Sierpinski triangles. This concept of points instead of drawing is new, below are the iterations lowers to 50, 500 and 5000 to reinforce the imagine created is by points. 

Starting with an original triangle, which has three sides and three points, you begin by connecting the midpoints of each side. This action creates three smaller triangles, one located at each corner of the original triangle. The process is then repeated for each of these remaining triangles: for each one, you again find the midpoints of its sides, connect them, and remove the new central triangle. As a result, each triangle once again divides into three smaller triangles, and this recursive process continues indefinitely, forming the self-similar structure of the Sierpinski Triangle.
 </p>
<figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/lab9a50.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> 50 points plotted
          </figcaption>
</figure>
<figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/lab9a500.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> 500 points plotted
          </figcaption>
</figure>	
	      
<figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/lab9a5000.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> 5000 points plotted
          </figcaption>
</figure>	 	      

<figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/lab9a.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong>  Sierpinski Triangle iteration original value from code 
          </figcaption>
</figure>

<p style="text-indent: 40px; line-height: 1.6;">
A modification for this would be changing the midpoint formula. Below the midpoint formula is raised .6, .7, .8 and then .9. This colapse the structure inside it self. An attempt to raise the ratio above. 1.0 cause an error, possible unbounded output. Changing the .5 in the midpoint to one resulted just a straight line.  
        </p>

<pre><code class="language-python">
def midpoint(P, Q):
    return (.5*(P[0] + Q[0]), .5*(P[1] + Q[1]))
</code></pre>
 
<figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/lab9am1.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Modification the midpoint formula from .5 to .6
          </figcaption>
</figure>

<figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/lab9am2.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Modification the midpoint formula from .5 to .7
          </figcaption>
</figure>

<figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/lab9am3.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Modification the midpoint formula from .5 to .8
          </figcaption>
</figure>

<figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/lab9am4.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Modification the midpoint formula from .5 to .9
          </figcaption>
</figure>
	    
<h3>2. Barnsley Fern (Iterated Function System)</h3>	    
	    
<p style="text-indent: 40px; line-height: 1.6;">

This code uses probabilities to set how often each of the f1-4 functions is called. The process to generate the Barnsley Fern begins by starting at the initial point (0, 0). At each step, the program randomly selects one of four transformation functions, with each choice weighted by a set probability. Once a function is selected, it is applied to the current (x, y) coordinates to calculate a new point. This new point is then saved. This process is repeated many times building a collection of points. When all points are plotted, the result forms the intricate, natural shape of a fern. 
 </p>


<p style="text-indent: 40px; line-height: 1.6;">
There are 4 functions f1, f2, f3, and f4, each taking (x, y) as input and returning a new (x, y) after a transformation. The function f1(x, y) shrinks y to 16 % of its original size, this creates the stem. The function f2(x, y) shrinks and rotates to create the left and right sides of the stems. and the function f3(x, y) he function f4 creates side leaves. 
 </p>

<pre><code class="language-python">
def f1(x, y):
    x = 0
    y = 0.16 * y
    return x, y
</code></pre>

<pre><code class="language-python">
def f2(x, y):
    x_new = 0.85 * x + 0.04 * y
    y_new = -0.04 * x + 0.85 * y + 1.6
    return x_new, y_new
</code></pre>

<pre><code class="language-python">
def f3(x, y):
    x_new = 0.2 * x - 0.26 * y
    y_new = 0.23 * x + 0.22 * y + 1.6
    return x_new, y_new
</code></pre>

<pre><code class="language-python">
def f4(x, y):
    x_new = -0.15 * x + 0.28 * y
    y_new = 0.26 * x + 0.24 * y + 0.44
    return x_new, y_new
</code></pre>
	      

<figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/lab9b.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Original 
          </figcaption>
</figure>
  
<p style="text-indent: 40px; line-height: 1.6;">

The original Barnsley Fern features small rotations and grows mostly vertically creating the appearance of a traditional green fern. In the modified "Spiral Fern" adjusts rotations to a curling effect at the tips, twisting patterns on left to right and patterns on the right move left. Other variations can be created like the "Longer Lsss Open Plant"  makes the leafs overlap as if they are a precurser in growth stage to the original. The Third modification plant example grows and spirals looks similar to a dandelion or cloud. Each modification changes the overall structure and style of the fractal.

</p>

<figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/lab9bm1.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Modification Curl, Twist
          </figcaption>
</figure>
	      
<figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/lab9bm2.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Modification Longer Less Open
          </figcaption>
</figure>

	    
<p style="text-indent: 40px; line-height: 1.6;">
Dandelion modifications in code: 
 </p>

 

<pre><code class="language-python">

def f1(x, y):
    x = 0
    y = 0.15 * y
    return x, y

def f2(x, y):
    x_new = 0.9 * x + 0.5 * y
    y_new = -0.5 * x + 0.5 * y + 1.0
    return x_new, y_new

def f3(x, y):
    x_new = 0.5 * x - 0.5 * y
    y_new = 0.5 * x + 0.5 * y + 1.0
    return x_new, y_new

def f4(x, y):
    x_new = -0.5 * x + 0.5 * y
    y_new = 0.5 * x + 0.5 * y + 1.0
    return x_new, y_new
</code></pre>



<figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/lab9bm3.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Modification Dandelion
          </figcaption>
</figure>






		
	    
<h3>3. L-Systems - Fractal Tree</h3>	



<p style="text-indent: 40px; line-height: 1.6;">
This next code, Lindenmayer System,  defines a recursive function to simulate how plants grow in biological structure.  This is done when repeatedly drawing branches based on geometric calculations. It starts with an initial point (x, y) and an angle, along with a specified branch length. At each step, the function checks whether the branch is longer than a minimum threshold; if it is, it continues. It then randomly chooses an angle variation between 20 and 40 degrees and a branch length reduction factor between 60% and 80%, introducing randomness to make the tree look more natural. The new endpoint of the branch is calculated using the x-coordinate adjusted by the cosine of the angle, and the y-coordinate by the sine of the angle, scaled by the branch length. From the new endpoint, two recursive calls are made to draw two new branches — one turning to the left and one to the right — each with a slightly rotated angle and a reduced length. This recursive splitting continues, creating smaller and smaller branches, until the branches become shorter than the threshold, at which point the recursion stops. This looks like a natural plant underwater, there is flow to it that is smooth in observation.
</p>

<figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/lab9c.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Barnsley Fern original
          </figcaption>
</figure>


<p style="text-indent: 40px; line-height: 1.6;">
A modification makes the tree structure appear less natural and by increasing the randomness in branching angles and reducing how much each new branch shrinks. The angles between branches are allowed to vary between 30° and 60°, resulting in a wider spread between left and right branches compared to the original. Additionally, the branch length shrinks less after each split, using a random factor between 70% and 90%, making the branches longer and the tree taller overall. These changes produce a tree that looks broader and less symmetrical, but since this became less lifelike, I chose to present in an alterative color. This almost gives a thrid demension when the idea is the overlap would be perceived as demenial. in this color looks more like a metal scrubbing pad.
</p>


<figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/lab9L2.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Barnsley Fern modification in growth and color change 
          </figcaption>
</figure>	    








	      

	    
<h3> 4. Hilbert Curve (Space-Filling Curve) </h3>


	    
<p style="text-indent: 40px; line-height: 1.6;">
Generates Hilbert Curves of increasing order.

Uses L-Systems for geometric recursion.
</p>	

<figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/lab9d.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Hilbert Curve
          </figcaption>
</figure>


<p style="text-indent: 40px; line-height: 1.6;">
Animated Hilbert Curve drawing.

Higher-order curves with color change by segment.
The Hilbert Curve elegantly fills space with increasing complexity, useful in data mapping and visual compression schemes.
	
</p>	
	    
<pre><code class="language-python">
import turtle
import time

turtle.speed(0)
turtle.hideturtle()
turtle.bgcolor("black")
turtle.color("cyan")

def draw_hilbert_curve(length, level, angle):
    if level == 0:
        return
    turtle.right(angle)
    draw_hilbert_curve(length, level-1, -angle)
    turtle.forward(length)
    turtle.left(angle)
    draw_hilbert_curve(length, level-1, angle)
    turtle.forward(length)
    draw_hilbert_curve(length, level-1, angle)
    turtle.left(angle)
    turtle.forward(length)
    draw_hilbert_curve(length, level-1, -angle)
    turtle.right(angle)

# Animate
turtle.penup()
turtle.goto(-200, 200)
turtle.pendown()

draw_hilbert_curve(10, 4, 90)
turtle.done()
	
</code></pre>	    
 	    
	      
<figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/lab9c.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Modification to Hilbert Curve
          </figcaption>
</figure>





		    


		    


	    
	    <!-- CONCLUSION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
        <h6>Conclusion</h6>
        <p>
		
This lab demonstrates fundamental and advanced fractal generation techniques. By modifying standard models:

Color gradients and randomness improve realism and visual appeal.

New fractal variations show creative extensions of mathematical concepts.

L-Systems offer rich flexibility in recursive graphics.

Future work could explore 3D fractals, interactive parameter tuning, and deeper stochastic systems for more lifelike simulations.


        </p>
      </section>

  </main>

<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>
