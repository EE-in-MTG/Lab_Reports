<!-- INTRODUCTION SECTION -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- --> 
<!-- -------------------------------------------------------------------------------------------- -->
<html>
<head> <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="stylesheet" href="https://latex.vercel.app/style.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css"/><script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]}};</script>

<title>Fractal Geometry Lab Report 9</title>
</head>
<body id="top">
  <header>
    <h1>Fractal Geometry Lab Report 9</h1>
    <h1>    Fractals and L-Systems</h1>
	  
    <p class="author">
      Joseph D Wilson <br />
      04/27/2025
    </p>
  </header>
  <main>
    <article class="indent-pars">
      
      <!-- INTRODUCTION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="introduction">
        <h2>Introduction</h2>
        <p>

This lab explores fractals and recursive pattern computation methods including the Chaos Game, Iterated Function Systems for the Barnsley Fern, and L-Systems. These fractals generate visually plant-like structures and space-filling curves such as the Hilbert Curve. We analyze, modify, and extend the code to enhance visual outcomes and explore modifications to fractal environments.
          
        </p>
      </section>
 
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->

      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
<h3>1. The Sierpinski Triangle via the Chaos Game</h3>

<p style="text-indent: 40px; line-height: 1.6;">
The original code randomly selects one of three triangle vertices, computes the midpoint between the current point and the selected vertex, and iterates this process to generate points converging on the Sierpinski Triangle.  
 </p>
<p style="text-indent: 40px; line-height: 1.6;">
The Chaos Game repeatedly moves halfway between the current point and a random triangle vertex.
 The code first creates a function “midpoint”, this function takes two points P=(x1,y1) and Q=(x2,y2), then calculates the midpoint formula M=((x1+x2)/2,(y1+y2)/2)and returns the midpoint between them. 
Next, the code creates a list equivalent of an equilateral triangle vertices. The list holds three tuples, which represent an XY point in a 2-dimensional plane. This gives shape of always being “bottom left”, “top”, and “bottom right” and restricts rotation, locking the 2D orientation of each triangle like grid. 
 </p>
<pre><code class="language-python">
vertices = [(0, 0), (2, 2*np.sqrt(3)), (4, 0)]
</code></pre>

<p style="text-indent: 40px; line-height: 1.6;">
The software creates two lists, using a variable iterations for the length of the lists X and Y. When created, they are filled with zeros. If the variable iterations = five, then the lists would look like 
 </p>
<pre><code class="language-python">
x = [0, 0, 0, 0, 0]
y = [0, 0, 0, 0, 0]
</code></pre>
<p style="text-indent: 40px; line-height: 1.6;">

This list works together to store the points that are created on the 2D plane. They are calculated in a for loop, with the length of iterations, by the midpoint function. So the concept is if you randomly take 1 of 3 ends of a triangle and record the midpoint, then continuing your recording will produce the Sierpinski triangles. This concept of points instead of drawing is new, below are the iterations lowers to 50,500 and 5000 to reinforce the imagine created is by points. 

Starting with an original triangle, which has three sides and three points, you begin by connecting the midpoints of each side. This action creates three smaller triangles, one located at each corner of the original triangle. The process is then repeated for each of these remaining triangles: for each one, you again find the midpoints of its sides, connect them, and remove the new central triangle. As a result, each triangle once again divides into three smaller triangles, and this recursive process continues indefinitely, forming the self-similar structure of the Sierpinski Triangle.
 </p>


	      

<figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/lab9a.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Original Sierpinski Triangle
          </figcaption>
</figure>

<p style="text-indent: 40px; line-height: 1.6;">
A modification for this would be adding color gradient to represent iteration progression as a representation of the time domain.Another modification can be on the shape of the triagnles, an option to change triangle shape scalene or isosceles can change the basic element fo the structure. The shape of the triangle can dramatically influence the overall pattern aesthetics. Color mapping iterations improves visual insight into convergence.
        </p>

<pre><code class="language-python">
import matplotlib.pyplot as plt
from random import random, randint
import numpy as np

def midpoint(P, Q):
    return (0.5 * (P[0] + Q[0]), 0.5 * (P[1] + Q[1]))

# Modified: Allow custom triangle vertices
vertices = [(0, 0), (2, 3), (4, 0)]  # Non-equilateral triangle
iterates = 50000
x, y = [0] * iterates, [0] * iterates
x[0], y[0] = random(), random()

colors = np.linspace(0, 1, iterates)  # Color gradient for plotting

for i in range(1, iterates):
    k = randint(0, 2)
    x[i], y[i] = midpoint(vertices[k], (x[i-1], y[i-1]))

plt.figure(figsize=(8, 8))
plt.scatter(x, y, c=colors, cmap='viridis', s=0.1)
plt.title('Modified Sierpinski Triangle with Color Gradient')
plt.axis('equal')
plt.show()
</code></pre>






	      
</code></pre>

	    <figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/lab9a1.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Modification
          </figcaption>
</figure>
	    
<h3>2. Barnsley Fern (Iterated Function System)</h3>	    
	    
<p style="text-indent: 40px; line-height: 1.6;">
Code uses four affine transformations with assigned probabilities and generates a self-similar Barnsley Fern.

 </p>

<figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/lab9b.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Original 
          </figcaption>
</figure>

<p style="text-indent: 40px; line-height: 1.6;">
 Code modifications use color mapping based on height/y-values and variation of the Barnsley Maple by modified coefficients.
 </p>

<pre><code class="language-python">
# Modified: Color based on y-value for height effect
x_vals, y_vals = zip(*fern_points)
colors = np.array(y_vals)

plt.figure(figsize=(6, 10))
plt.scatter(x_vals, y_vals, c=colors, cmap='summer', s=0.1)
plt.title('Barnsley Fern with Height-based Color')
plt.show()

# New: Maple-style variant of Barnsley Fern
def barnsley_maple(iterations):
    x, y = 0, 0
    points = []
    for _ in range(iterations):
        rand = random.random()
        if rand < 0.02:
            x, y = 0, 0.25 * y
        elif rand < 0.84:
            x, y = 0.85 * x + 0.02 * y, -0.02 * x + 0.85 * y + 1.6
        elif rand < 0.92:
            x, y = 0.2 * x - 0.31 * y, 0.255 * x + 0.245 * y + 0.29
        else:
            x, y = -0.25 * x + 0.28 * y, 0.26 * x + 0.24 * y + 0.44
        points.append((x, y))
    return points

maple_points = barnsley_maple(iterations)
x_maple, y_maple = zip(*maple_points)

plt.figure(figsize=(6, 10))
plt.scatter(x_maple, y_maple, s=0.1, color='darkred')
plt.title('Barnsley Maple Variant')
plt.show()

</code></pre>
	    
<figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/lab9b1.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Modification
          </figcaption>
</figure>

	    
<h3>3. L-Systems - Fractal Tree</h3>	



<p style="text-indent: 40px; line-height: 1.6;">
Uses recursive rules to simulate branching patterns.

Classic fractal tree model. 
</p>

<figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/lab9c.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Barnsley Fern original
          </figcaption>
</figure>


	    


<p style="text-indent: 40px; line-height: 1.6;">
Added randomness to angle and length for a more natural look.

Customizable depth and angle.

Randomized trees mimic natural growth more closely, enhancing realism over strictly deterministic fractals.
</p>


	    
<pre><code class="language-python">
	
# Randomized tree-like fractal
import turtle
import random

turtle.speed(0)
turtle.hideturtle()
turtle.bgcolor("black")
turtle.color("lime")

def draw_branch(branch_length, t):
    if branch_length > 5:
        angle = random.randint(20, 40)
        length_factor = random.uniform(0.6, 0.8)

        t.forward(branch_length)
        t.left(angle)
        draw_branch(branch_length * length_factor, t)
        t.right(angle * 2)
        draw_branch(branch_length * length_factor, t)
        t.left(angle)
        t.backward(branch_length)

# Initial call
turtle.left(90)
turtle.penup()
turtle.goto(0, -250)
turtle.pendown()
draw_branch(100, turtle)
turtle.done()

</code></pre>

<figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/lab9c1.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Modification
          </figcaption>
</figure>


	    
<h3> 4. Hilbert Curve (Space-Filling Curve) </h3>


	    
<p style="text-indent: 40px; line-height: 1.6;">
Generates Hilbert Curves of increasing order.

Uses L-Systems for geometric recursion.
</p>	

<figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/lab9d.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Hilbert Curve
          </figcaption>
</figure>


<p style="text-indent: 40px; line-height: 1.6;">
Animated Hilbert Curve drawing.

Higher-order curves with color change by segment.
The Hilbert Curve elegantly fills space with increasing complexity, useful in data mapping and visual compression schemes.
	
</p>	
	    
<pre><code class="language-python">
import turtle
import time

turtle.speed(0)
turtle.hideturtle()
turtle.bgcolor("black")
turtle.color("cyan")

def draw_hilbert_curve(length, level, angle):
    if level == 0:
        return
    turtle.right(angle)
    draw_hilbert_curve(length, level-1, -angle)
    turtle.forward(length)
    turtle.left(angle)
    draw_hilbert_curve(length, level-1, angle)
    turtle.forward(length)
    draw_hilbert_curve(length, level-1, angle)
    turtle.left(angle)
    turtle.forward(length)
    draw_hilbert_curve(length, level-1, -angle)
    turtle.right(angle)

# Animate
turtle.penup()
turtle.goto(-200, 200)
turtle.pendown()

draw_hilbert_curve(10, 4, 90)
turtle.done()
	
</code></pre>	    
 	    
	      
<figure>
          <img 
		  src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/lab9c.jpg"
	
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Modification to Hilbert Curve
          </figcaption>
</figure>





		    


		    


	    
	    <!-- CONCLUSION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
        <h6>Conclusion</h6>
        <p>
		
This lab demonstrates fundamental and advanced fractal generation techniques. By modifying standard models:

Color gradients and randomness improve realism and visual appeal.

New fractal variations show creative extensions of mathematical concepts.

L-Systems offer rich flexibility in recursive graphics.

Future work could explore 3D fractals, interactive parameter tuning, and deeper stochastic systems for more lifelike simulations.


        </p>
      </section>

  </main>

<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>
