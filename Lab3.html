<!-- INTRODUCTION SECTION -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<html>
<head> <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="stylesheet" href="https://latex.vercel.app/style.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css"/><script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]}};</script>

<title>Fractal Geometry Lab Report</title>

</head>
	
<body id="top">




  <header>
    <h1>Fractal Geometry Lab Report 3</h1>
    <p class="author">
      Joseph D Wilson <br />
      02/10/2025
    </p>
  </header>
  


  <main>
    <article class="indent-pars">
      
      <!-- INTRODUCTION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="introduction">
        <h2>Introduction</h2>
        <p>
          This is lab 3 "Three sides to the Triangle". This lab is to contruct and visualize Sierpinski triangle, explore recursive vs chaos game approaches.
        </p>
      </section>


     
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->


      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
     
	      <h3>a. Sierpinski Triangle</h3>
<p style="text-indent: 40px; line-height: 1.6;">
This lab begins with defining to draw a triangle with the function "draw_triangle" which takes in the argument length and draws an equilateral triangle. The system is setup to face 90 so the drawing will begin horizontal moving toward the viewers right, then rotate counter clockwise on the screen where the second line will be drawn. When the three passes of the for loop are completed the pointer will return to the original direction and position. 
        </p>

<pre><code class="language-python">
# Define the function to draw an equilateral triangle
def draw_triangle(length):
    for _ in range(3):
        forward(length)
        left(120)
</code></pre>
	      
<p style="text-indent: 40px; line-height: 1.6;">
The next function defines in the code is named "sierpinski_triangle" and takes the length argument and an additional argument named "order". This function is and if/else state and uses the recursian and the reduction of the "order" variable to reach a base case. The code reduces the length by 2 and the data is loaded back into the same function much like lab 2. The "sierpinski_triangle" funcation calls backwards function twice in the code below. 
</p>		
<pre><code class="language-python">
# Define the recursive Sierpinski triangle function
def sierpinski_triangle(length, order):
    if order == 0:
        draw_triangle(length)
    else:
        sierpinski_triangle(length / 2, order - 1)
        forward(length / 2)
        sierpinski_triangle(length / 2, order - 1)
        backward(length / 2)
        left(60)
        forward(length / 2)
        right(60)
        sierpinski_triangle(length / 2, order - 1)
        left(60)
        backward(length / 2)
        right(60)
</code></pre>	
	      
<p style="text-indent: 40px; line-height: 1.6;">
The inclusion of backwards is allowing the triangles to "fit" more than one inside the outter triangles. The concept of order and the recursion allows to interpret the inner smallest trianles at order zero, the table below compares the valus of the variable "order" and "length". From the table below and the code, the only time a triangle is drawn is when the length is 25, the smallest length calcualted. 	
</p>

	      	    
<!-- Insert Table Here -->
<table>
  <thead>
    <tr>
      <th># sides of smallest length</th>
      <th>Value of Order</th>
      <th>Value of length</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>243</td>
      <td>      4 </td>
      <td>    200 </td>
         
    </tr>
    <tr>
      <td>81 </td>
      <td>      3 </td>
      <td>   100 </td>
    </tr>
    <tr>
      <td>27</td>
      <td>      2</td>
      <td>  50</td>
    </tr>
    <tr>
      <td>9</td>
      <td>      1</td>
      <td>25</td>
    </tr>
	<tr>
      <td>3</td>
      <td>      0</td>
      <td>25</td>
    </tr>
  </tbody>
</table>


<p style="text-indent: 40px; line-height: 1.6;">
The image below will try to show that when the order varaible was changed from 4 to 2 in the lower section, the amount of inner triangles was not created. The forward, backward, left and right still mages the placement of three "sections" or the same order and length. 
</p>	

        <figure>
          <img
            src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/L3order.jpg"
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> In the upper plot order variable is four, lower plot has variable order set to 2. 
          </figcaption>
        </figure>

<p style="text-indent: 40px; line-height: 1.6;">
 This example of recursive function calls draws the smallest set first, uses a variable decrement to reach a base case. To calculate how many of the smallest size of length will be drawn and relate tovariabel order, $$ =3(n^n), $$.
</p>



	      
<h4>b. Cellular Automata</h4>

	
      </section>
<p style="text-indent: 40px; line-height: 1.6;">	      
This next section for the lab uses a library import to include numpy and sets as the variable no, then also matplot as plot. This is common to setup and use functions of these libnraries. 
</p>	
	    
<pre><code class="language-python">
import numpy as np
import matplotlib.pyplot as plt
</code></pre>

	    
<p style="text-indent: 40px; line-height: 1.6;">
This code is going to use numerical array, to begin there is a setup for all zeros in a m by n matrix of 100 by 100. To display the way the plot will be used, there is a plot and a placement of a one, as in binary one being the state of on, and a plot is shown to express where the coordiante of (0,50) is located. This output cell hass all black cells with a whiote cell in the middle of the top row. m being rows and n being coplumns, this placement of (0,50). 
</p>		
	    
<p style="text-indent: 40px; line-height: 1.6;">
The lab next uses creates a variable named "num" and itializes to the value 90, then a print statement is used to how an 8 bit binary output for the num varialbe. Next a three dementional array of 2 by 2 by 2 is created. After initialized, multiple arrary locations are assigned in a binary order, but because of the ability for the number value 9 in binary to be able to be reversed, there is not an immediate understadn of MSB and LSB position. Reding this cell from top to bottom or reading this from bottom to top yields the same output. 
</p>
	    
<p style="text-indent: 40px; line-height: 1.6;">
The function CA(X) is defined and called with the 100 by 100 array created earlier. This array only had 1 "on" marked at (0, 50). This function goes through the shape and applies the "rule" created earlier from the binary of "9" much like a look up table. The three demensional array is used to compare the current, previous and next value and the output set in the "rule" array will be plotted as either 1=on or 0=off. The loops are processed downward on the output cell, each time the rule is applied, it is comparing that values of the previous rows left, center and right. The image a table below are to compare the initial rows. 
</p>


<p>
 
</p>
        <figure>
          <img
            src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/?"
            alt="cvariable order"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> The image above helps to userstand the code provided. 
          </figcaption>
        </figure>
<p style="text-indent: 40px; line-height: 1.6;">

</p>
	    
<!-- Insert Table Here -->
<table>
  <thead>
    <tr>
      <th>row</th>
      <th>values in row</th>
      
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>	00000000000000000000000000000100000000000000000000000</td>
         
    </tr>
    <tr>
      <td>1</td>
      <td>      00000000000000000000000000001010000000000000000000000</td>
    </tr>
    <tr>
      <td>2</td>
      <td>      00000000000000000000000000010101000000000000000000000</td>
    </tr>
    <tr>
      <td>3</td>
      <td>      	00000000000000000000000000101010100000000000000000000</td>
    </tr>
  </tbody>
</table>

      <!-- CONCLUSION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
        <h6>Conclusion</h6>
        <p>
          conclusion
        </p>
      </section>

     
     
     
   
     
     
     
  </main>

<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>
