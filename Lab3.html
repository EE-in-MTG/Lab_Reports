<!-- INTRODUCTION SECTION -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<html>
<head> <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="stylesheet" href="https://latex.vercel.app/style.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css"/><script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]}};</script>

<title>Fractal Geometry Lab Report</title>

</head>
	
<body id="top">




  <header>
    <h1>Fractal Geometry Lab Report 3</h1>
    <p class="author">
      Joseph D Wilson <br />
      02/10/2025
    </p>
  </header>
  


  <main>
    <article class="indent-pars">
      
      <!-- INTRODUCTION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="introduction">
        <h2>Introduction</h2>
        <p>
          This is lab 3 "Three sides to the Triangle". This lab is to contruct and visualize Sierpinski triangle, explore recursive vs chaos game approaches.
        </p>
      </section>


     
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->


      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
     
	      <h3>a. Sierpinski Triangle</h3>
<p style="text-indent: 40px; line-height: 1.6;">
This lab begins with defining to draw a triangle with the function "draw_triangle" which takes in the argument length and draws an equilateral triangle. The system is setup to face 90 so the drawing will begin horizontal moving toward the viewers right, then rotate counter clockwise on the screen where the second line will be drawn. When the three passes of the for loop are completed the pointer will return to the original direction and position. 
        </p>

<pre><code class="language-python">
# Define the function to draw an equilateral triangle
def draw_triangle(length):
    for _ in range(3):
        forward(length)
        left(120)
</code></pre>
	      
<p style="text-indent: 40px; line-height: 1.6;">
The next function defines in the code is named "sierpinski_triangle" and takes the length argument and an additional argument named "order". This function is and if/else state and uses the recursian and the reduction of the "order" variable to reach a base case. The code reduces the length by 2 and the data is loaded back into the same function much like lab 2. The "sierpinski_triangle" funcation calls backwards function twice in the code below. 
</p>		
<pre><code class="language-python">
# Define the recursive Sierpinski triangle function
def sierpinski_triangle(length, order):
    if order == 0:
        draw_triangle(length)
    else:
        sierpinski_triangle(length / 2, order - 1)
        forward(length / 2)
        sierpinski_triangle(length / 2, order - 1)
        backward(length / 2)
        left(60)
        forward(length / 2)
        right(60)
        sierpinski_triangle(length / 2, order - 1)
        left(60)
        backward(length / 2)
        right(60)
</code></pre>	
	      
<p style="text-indent: 40px; line-height: 1.6;">
The inclusion of backwards is allowing the triangles to "fit" more than one inside the outter triangles. The concept of order and the recursion allows to interpret the inner smallest trianles at order zero, the table below compares the valus of the variable "order" and "length". From the table below and the code, the only time a triangle is drawn is when the length is 25, the smallest length calcualted. 	
</p>

	      	    
<!-- Insert Table Here -->
<table>
  <thead>
    <tr>
      <th># sides of smallest length</th>
      <th>Value of Order</th>
      <th>Value of length</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>243</td>
      <td>      4 </td>
      <td>    200 </td>
         
    </tr>
    <tr>
      <td>81 </td>
      <td>      3 </td>
      <td>   100 </td>
    </tr>
    <tr>
      <td>27</td>
      <td>      2</td>
      <td>  50</td>
    </tr>
    <tr>
      <td>9</td>
      <td>      1</td>
      <td>25</td>
    </tr>
	<tr>
      <td>3</td>
      <td>      0</td>
      <td>25</td>
    </tr>
  </tbody>
</table>


<p style="text-indent: 40px; line-height: 1.6;">
The image below will try to show that when the order varaible was changed from 4 to 2 in the lower section, the amount of inner triangles was not created. The forward, backward, left and right still mages the placement of three "sections" or the same order and length. 
</p>	

        <figure>
          <img
            src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/L3order.jpg"
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> In the upper plot order variable is four, lower plot has variable order set to 2. 
          </figcaption>
        </figure>

<p style="text-indent: 40px; line-height: 1.6;">
 This example of recursive function calls draws the smallest set first, uses a variable decrement to reach a base case. To calculate how many of the smallest size of length will be drawn and relate tovariabel order, $$ =3(n^n), $$.
</p>



	      
<h4>b. section title</h4>

	
      </section>
<p style="text-indent: 40px; line-height: 1.6;">	      
text
</p>		
<p style="text-indent: 40px; line-height: 1.6;">
text 
</p>		
<p style="text-indent: 40px; line-height: 1.6;">
text
        </p>






	      <p>
For another understanding of recursive function calls, the recursive function could have been rewritten using a for loop. In this case, recursion can be thought of as function calls acting similarly to loop iterations.  Each recursive call being comparable to an execution of the loop, decrementing the "order" variable at each step. Interpreting when the variable "order" and the recursive nature of the function has been drawn onto the output cell below. This would be one example of each so the overlap can be easily identified. 
	      </p>
        <figure>
          <img
            src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/variableOrder2.jpg"
            alt="cvariable order"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Segments highlighted of the variable "order". 
          </figcaption>
        </figure>
<p style="text-indent: 40px; line-height: 1.6;">
From the figure above, the table below will relate these sections to their value of the variables which are the order and length when the function is running.
</p>
	    
<!-- Insert Table Here -->
<table>
  <thead>
    <tr>
      <th>Segment</th>
      <th>Value of Order</th>
      <th>Value of length</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Segment 3</td>
      <td>      3</td>
      <td>    400/3</td>
         
    </tr>
    <tr>
      <td>Segment 2</td>
      <td>      2</td>
      <td>   (400/3)/3</td>
    </tr>
    <tr>
      <td>Segment 1</td>
      <td>      1</td>
      <td>  [(400/3)/3]/3</td>
    </tr>
    <tr>
      <td>Segment 0</td>
      <td>      0</td>
      <td>([(400/3)/3]/3)/3</td>
    </tr>
  </tbody>
</table>


	      <h5>c. Dragon Curves</h5>

	      <p style="text-indent: 40px; line-height: 1.6;">
The Dragon Curve function uses order, length and turn direct to draw. In this example the length is set to always be 1 but has a place to alter this and variable new length. Dragon Curve is built on the recursive function and has a base function when the variable order is equal to zero. The first four, beginning with zero, examples for functions in the figure below will show the building up to the Dragon Curve. This is opposite to the normal decrement that is removing one from the current value of the variable "order".  The function has a built in flipflop gate for the direction to alternate the direction and the turn is set to always be 90 degrees. The built-in direction is setup for right/left as positive 90 and negative 90-degree alternating. 
		      </p>		


	              <figure>
          <img
            src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/DragonCurveOrder0123.jpg"
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> top left order = 0, bottom left order = 1, top right order = 2, bottom right order = 3 
          </figcaption>
        </figure>
      </section>

	    
	      <p style="text-indent: 40px; line-height: 1.6;">
The table below helps understand the data used in the Dragon Curve function and predict future uses for variable and dimensions. 
        </p>

	    
<!-- Insert Table Here -->
<table>
  <thead>
    <tr>
 
      <th>Value of Order</th>
      <th>Number of Segment</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>1</td>   
    </tr>
    <tr>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <td>2</td>
      <td>4</td>
    </tr>
    <tr>
      <td>n</td>
      <td>2^n</td>
    </tr>
  </tbody>
</table>


	    	      <p style="text-indent: 40px; line-height: 1.6;">

        </p>

	    <p style="text-indent: 40px; line-height: 1.6;">
	The only time data is set to be drawn on the screen is when the "order" variable is equal to zero. The code makes left and right turns durin iterations, the drawing does not happen on every iteration of the function. The order controls the number of times the turtle will change directions, then only on the order zero will there be a draw event. 
The table below is make to understand the turns used in the Dragon Curve function and shows exponential growth in the decision that is the turn before each segment is drawn at the variable order equals zero. 
	
        </p>
<!-- Insert Table Here -->
<table>
  <thead>
    <tr>
 
      <th>Value of Order</th>
      <th>Turns</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>No turns</td>   
    </tr>
    <tr>
      <td>1</td>
      <td>R </td>
    </tr>
    <tr>
      <td>2</td>
      <td>R L</td>
    </tr>
    <tr>
      <td>3</td>
      <td>R L R</td>
    </tr>
    <tr>
      <td>4</td>
      <td>R L R R L</td>
    </tr>
    <tr>
      <td>5</td>
      <td>R L R R L R L R</td>
    </tr>
  </tbody>
</table>
      <!-- CONCLUSION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
        <h6>Conclusion</h6>
        <p>
          Fractal Geometry involves recursive functions and math patterns to be represented on a computer. For this lab, Brownian motion, Koch curves, and Dragon curves iterate through functions and are plotted for interpretation. The Brownian motion showed how random can be applied to degrees in turning. Randomness in directionally selection made the output unpredictable. The Koch curve gave us an inspection of the recursive function and understanding of the base condition when brings recursion to an end. The Dragon curve showed recursion in turning and was difficult to predict the pattern due to the exponentially higher calculations for the turns when including higher order functions. With a better understanding of recursion on a computer platform, functions are and recursion are the main elements for fractal geometry. The big take away is that something has to change and then be feedback in to get recursion. Here the ability to stop with and else/if statement means that on the computer, we can stop the recursion, but I do not see how that is represented in other environments. 
        </p>
      </section>

     
     
     
   
     
     
     
  </main>

<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>
