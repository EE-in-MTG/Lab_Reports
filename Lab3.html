<!-- INTRODUCTION SECTION -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<html>
<head> <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="stylesheet" href="https://latex.vercel.app/style.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css"/><script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]}};</script>

<title>Fractal Geometry Lab Report</title>

</head>
	
<body id="top">




  <header>
    <h1>Fractal Geometry Lab Report 3</h1>
    <p class="author">
      Joseph D Wilson <br />
      02/10/2025
    </p>
  </header>
  


  <main>
    <article class="indent-pars">
      
      <!-- INTRODUCTION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="introduction">
        <h2>Introduction</h2>
        <p>
          This is lab 3 "Three sides to the Triangle". This lab is to contruct and visualize Sierpinski triangle, explore recursive vs chaos game approaches.
        </p>
      </section>


     
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->


      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
     
	      <h3>a. Sierpinski triangle</h3>
<p style="text-indent: 40px; line-height: 1.6;">
This lab begins with defining to draw a triangle with the function "draw_triangle" which takes in the argument length and draws an equilateral triangle. The system is setup to face 90 so the drawing will begin horizontal moving toward the viewers right, then rotate counter clockwise on the screen where the second line will be drawn. When the three passes of the for loop are completed the pointer will return to the original direction and position. 
        </p>

	      	<pre><code class="language-python">
# Define the function to draw an equilateral triangle
def draw_triangle(length):
    for _ in range(3):
        forward(length)
        left(120)
	</code></pre>
<p style="text-indent: 40px; line-height: 1.6;">
The next function defines in the code is named "sierpinski_triangle" and takes the length argument and an additional argument named "order". This function is and if/else state and uses the recursian and the reduction of the "order" variable to reach a base case. The code reduces the length by 2 and the data is loaded back into the same function much like lab 2. This makes familiarity of the setup easy to understand the code. A question that comes with being familiar would be if there is a process for rescurian of multiple functions. 
</p>		

 
<h4>b. Koch Curves</h4>

	
      </section>
<p style="text-indent: 40px; line-height: 1.6;">	      
In the Blipline function, the first example of recursion is used in the code notebook. The function calls itself to mathematically reduce the size of the arguments passed to the next call. The recursive function has a built-in stop condition determined by the variable "order", which decrements with each recursive call until it reaches zero.
An if/else statement looks for that value zero and then a straight line is drawn on the final function call. This final function call is referred to as the base case, where the recursive function stops executing. If a base case is not included in programming, there is a potential of infinite recursion. In our platform host based programming, without the base case codded into the recursive function, errors may occur depending on the platform's available resources.
</p>		
<p style="text-indent: 40px; line-height: 1.6;">
Interestingly, this type of programming may have a correlation to denial-of-service (DoS) attacks in computer networking, where excessive recursive calls or loops overwhelm system resources. The possibility of better understanding base case could lead to development of protection against this attack method.  
</p>		
<p style="text-indent: 40px; line-height: 1.6;">
The function process is elevated to a third order and output visualization is understandable. Next the blip_line function is called in a new function named the kock_snowflake function. Added into his function is a right turn of 120 degree which makes the order of 3 end up and the beginning by 120 + 120 + 120 = 360 degrees as shown in the figure below.  
        </p>




        <figure>
          <img
            src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/120degrees.jpg"
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Interpreting the 120 degrees right from code drawn onto the output cell. 
          </figcaption>
        </figure>

	      <p>
For another understanding of recursive function calls, the recursive function could have been rewritten using a for loop. In this case, recursion can be thought of as function calls acting similarly to loop iterations.  Each recursive call being comparable to an execution of the loop, decrementing the "order" variable at each step. Interpreting when the variable "order" and the recursive nature of the function has been drawn onto the output cell below. This would be one example of each so the overlap can be easily identified. 
	      </p>
        <figure>
          <img
            src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/variableOrder2.jpg"
            alt="cvariable order"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Segments highlighted of the variable "order". 
          </figcaption>
        </figure>
<p style="text-indent: 40px; line-height: 1.6;">
From the figure above, the table below will relate these sections to their value of the variables which are the order and length when the function is running.
</p>
<!-- Insert Table Here -->
<table>
  <thead>
    <tr>
      <th>Segment</th>
      <th>Value of Order</th>
      <th>Value of length</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Segment 3</td>
      <td>      3</td>
      <td>    400/3</td>
         
    </tr>
    <tr>
      <td>Segment 2</td>
      <td>      2</td>
      <td>   (400/3)/3</td>
    </tr>
    <tr>
      <td>Segment 1</td>
      <td>      1</td>
      <td>  [(400/3)/3]/3</td>
    </tr>
    <tr>
      <td>Segment 0</td>
      <td>      0</td>
      <td>([(400/3)/3]/3)/3</td>
    </tr>
  </tbody>
</table>


	      <h5>c. Dragon Curves</h5>

	      <p style="text-indent: 40px; line-height: 1.6;">
The Dragon Curve function uses order, length and turn direct to draw. In this example the length is set to always be 1 but has a place to alter this and variable new length. Dragon Curve is built on the recursive function and has a base function when the variable order is equal to zero. The first four, beginning with zero, examples for functions in the figure below will show the building up to the Dragon Curve. This is opposite to the normal decrement that is removing one from the current value of the variable "order".  The function has a built in flipflop gate for the direction to alternate the direction and the turn is set to always be 90 degrees. The built-in direction is setup for right/left as positive 90 and negative 90-degree alternating. 
		      </p>		


	              <figure>
          <img
            src="https://raw.githubusercontent.com/EE-in-MTG/Lab_Reports/main/DragonCurveOrder0123.jpg"
            alt="120 degrees"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> top left order = 0, bottom left order = 1, top right order = 2, bottom right order = 3 
          </figcaption>
        </figure>
      </section>

	    
	      <p style="text-indent: 40px; line-height: 1.6;">
The table below helps understand the data used in the Dragon Curve function and predict future uses for variable and dimensions. 
        </p>

	    
<!-- Insert Table Here -->
<table>
  <thead>
    <tr>
 
      <th>Value of Order</th>
      <th>Number of Segment</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>1</td>   
    </tr>
    <tr>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <td>2</td>
      <td>4</td>
    </tr>
    <tr>
      <td>n</td>
      <td>2^n</td>
    </tr>
  </tbody>
</table>


	    	      <p style="text-indent: 40px; line-height: 1.6;">

        </p>

	    <p style="text-indent: 40px; line-height: 1.6;">
	The only time data is set to be drawn on the screen is when the "order" variable is equal to zero. The code makes left and right turns durin iterations, the drawing does not happen on every iteration of the function. The order controls the number of times the turtle will change directions, then only on the order zero will there be a draw event. 
The table below is make to understand the turns used in the Dragon Curve function and shows exponential growth in the decision that is the turn before each segment is drawn at the variable order equals zero. 
	
        </p>
<!-- Insert Table Here -->
<table>
  <thead>
    <tr>
 
      <th>Value of Order</th>
      <th>Turns</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>No turns</td>   
    </tr>
    <tr>
      <td>1</td>
      <td>R </td>
    </tr>
    <tr>
      <td>2</td>
      <td>R L</td>
    </tr>
    <tr>
      <td>3</td>
      <td>R L R</td>
    </tr>
    <tr>
      <td>4</td>
      <td>R L R R L</td>
    </tr>
    <tr>
      <td>5</td>
      <td>R L R R L R L R</td>
    </tr>
  </tbody>
</table>
      <!-- CONCLUSION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
        <h6>Conclusion</h6>
        <p>
          Fractal Geometry involves recursive functions and math patterns to be represented on a computer. For this lab, Brownian motion, Koch curves, and Dragon curves iterate through functions and are plotted for interpretation. The Brownian motion showed how random can be applied to degrees in turning. Randomness in directionally selection made the output unpredictable. The Koch curve gave us an inspection of the recursive function and understanding of the base condition when brings recursion to an end. The Dragon curve showed recursion in turning and was difficult to predict the pattern due to the exponentially higher calculations for the turns when including higher order functions. With a better understanding of recursion on a computer platform, functions are and recursion are the main elements for fractal geometry. The big take away is that something has to change and then be feedback in to get recursion. Here the ability to stop with and else/if statement means that on the computer, we can stop the recursion, but I do not see how that is represented in other environments. 
        </p>
      </section>

     
     
     
   
     
     
     
  </main>

<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>
